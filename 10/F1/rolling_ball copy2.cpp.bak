#include <bits/stdc++.h>
#include <random>
#include "draw_geometry.hpp"
#include <chrono>

using namespace std::chrono;

Sphere ball (25.0, 16, 8);
Cylinder ballDirAx (1.5, 40.0, 8);
Cone ballDirHd (3.0, 10.0, 8);

double ballCtrlAngle = 45, ballPosX = 0, ballPosY = 0, boundary = 200;
double simVel = 300, mspf = 30;
bool simulation = false;
high_resolution_clock::time_point tStart;

Line lookAt (250, 250, 300, 0, 0, 0);

void init(){
    printf("Do your initialization here\n");
    drawaxes = 1;
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set background color to black and opaque
    glClearDepth(1.0f);
    glEnable(GL_DEPTH_TEST);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    gluPerspective(50, 1, 1, 2000.0);
    initCamVecs();
}

void drawAxes() {
	if (drawaxes) {
		glColor3f(1.0, 1.0, 0.0);
		glBegin(GL_LINES); {
			glVertex3f( 100,0,0);
			glVertex3f(-100,0,0);

			glVertex3f(0,-100,0);
			glVertex3f(0, 100,0);

			glVertex3f(0,0, 100);
			glVertex3f(0,0,-100);
		} glEnd();
	}
}

void drawBoard() {
    if (drawboard) {
        glBegin(GL_QUADS); {
            for (int i = -4000; i<+4000; i+=50) {
                for (int j = -4000; j<+4000; j+=50) {
                    if ((i+j)%100) glColor3f(0.2, 0.2, 0.2);
                    else glColor3f(0.8, 0.8, 0.8);
                    glVertex3f(i, j, 0);
                    glVertex3f(i+50, j, 0);
                    glVertex3f(i+50, j+50, 0);
                    if ((i+j)%100) glColor3f(0, 0, 0);
                    else glColor3f(1, 1, 1);
                    glVertex3f(i, j+50, 0);
                };
            };
        } glEnd();
    };
};

void drawWalls (double L, double h) {
    for (int i=0; i<4; i++) {
        glPushMatrix();
            glRotatef (90*i, 0, 0, 1);
            glBegin (GL_QUADS); {
                glColor3f (0.4, 0.2, 0.1);
                glVertex3f (-L, -L, h);
                glVertex3f (-L, -L, 0);
                glVertex3f (-L, +L, 0);
                glColor3f (0.6, 0.3, 0.15);
                glVertex3f (-L, +L, h);
            } glEnd();
        glPopMatrix();
    };
};

void rollBall (double a) {
    double A = ballCtrlAngle * M_PI/180;
    double d = a/360 * 2 * M_PI * ball.r;
    double dX = d*cos(A), dY = d*sin(A), dX0;

    dX0 = dX;
    if (fabs(ballPosX+dX) > boundary-ball.r) {
        dX = boundary-ball.r - fabs(ballPosX);
        dY = dX * tan(A);
        A = fmod (atan2(+sin(A),-cos(A)) + 2*M_PI, 2*M_PI);
    } else if (fabs(ballPosY+dY) > boundary-ball.r) {
        dY = boundary-ball.r - fabs(ballPosY);
        dX = dY / tan(A);
        A = fmod (atan2(-sin(A),+cos(A)) + 2*M_PI, 2*M_PI);
    };
    ballCtrlAngle = 180.0/M_PI * A;
    ballPosX += dX, ballPosY += dY;
    Vec* v = new Vec (-sin(A), cos(A), 0);
    ball.rotate (v, a*dX/dX0);    
};

void simSchedColl(int);

void simFlipX (int arg) {
    if (fabs(ballPosX) < boundary-ball.r) simSchedColl(0);
    double A = ballCtrlAngle * M_PI/180;
    A = fmod (atan2(+sin(A),-cos(A)) + 2*M_PI, 2*M_PI);
    ballCtrlAngle = 180.0/M_PI * A;
    simSchedColl(0);
};

void simFlipY (int arg) {
    if (fabs(ballPosY) < boundary-ball.r) simSchedColl(0);
    double A = ballCtrlAngle * M_PI/180;
    A = fmod (atan2(-sin(A),+cos(A)) + 2*M_PI, 2*M_PI);
    ballCtrlAngle = 180.0/M_PI * A;
    simSchedColl(0);
};

void simulateBall (int arg) {
    if (simulation) {
        double a = simVel / 1000.0 * mspf;
        double A = ballCtrlAngle * M_PI/180.0, d = a/360 * 2 * M_PI * ball.r;
        double dX = d*cos(A), dY = d*sin(A);
        ballPosX += dX, ballPosY += dY;
        Vec* v = new Vec (-sin(A), cos(A), 0);
        ball.rotate (v, a);    
        glutTimerFunc (mspf, simulateBall, 0);
    }
};

void simSchedColl (int arg ) {
    double a = simVel / 1000.0;
    double A = ballCtrlAngle * M_PI/180.0, d = a/360 * 2 * M_PI * ball.r;
    double dX = d*cos(A), dY = d*sin(A);

    double tX = fabs (((dX>0? +1:-1)*(boundary-ball.r)-ballPosX) / dX);
    double tY = fabs (((dY>0? +1:-1)*(boundary-ball.r)-ballPosY) / dY);
    // cout << tX << " " << tY << endl;
    if (tX<tY) glutTimerFunc (tX, simFlipX, 0);
    else glutTimerFunc (tY, simFlipY, 0);
};

void keyboardListener(unsigned char key,int x, int y){
    camKeyboardListener(key);
    if (key == 'j') {
        ballCtrlAngle = fmod (ballCtrlAngle + 15 + 360, 360);
    } else if (key == 'l') {
        ballCtrlAngle = fmod (ballCtrlAngle - 15 + 360, 360);
    } else if (key == 'i') {
        rollBall(+15);
    } else if (key == 'k') {
        rollBall(-15);
    } else if (key == ' ') {
        simulation = !simulation;
    };
    if (simulation) simSchedColl(0),simulateBall(0);
};


void specialKeyboardListener(int key,int x, int y){
    camSpecialKeyboardListener(key);
};


double _rand(){
    return (double)rand() / RAND_MAX;
}

void display() {    
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
   
    gluLookAt  (lookAt.p1->x, lookAt.p1->y, lookAt.p1->z, 
                lookAt.p2->x, lookAt.p2->y, lookAt.p2->z,  
                upVec->x, upVec->y, upVec->z);
    drawBoard();
    drawWalls (boundary, 40);

    glPushMatrix();       
        glTranslatef(ballPosX,ballPosY,ball.r);
        drawSphere(&ball);

        if (drawUpArrow) {
            glPushMatrix();
                glTranslatef(0, 0, ball.r);
                drawArrow(&ballDirAx, &ballDirHd, 1);
            glPopMatrix();
        };
        
        glPushMatrix();
            glRotatef(ballCtrlAngle, 0, 0 ,1);
            glPushMatrix();
                glRotatef(90, 0, 1, 0);
                drawArrow(&ballDirAx, &ballDirHd);
            glPopMatrix();
        glPopMatrix();
    glPopMatrix();

    glutSwapBuffers();

}

void idle(){
    if (time(0)%2) drawUpArrow = true;
    else drawUpArrow = false;
    glutPostRedisplay();
    // cout << ballCtrlAngle << endl;
}

int main(int argc,char** argv){
    glutInit(&argc,argv);
    glutInitWindowSize(800, 800);   // Set the window's initial width & height
    glutInitWindowPosition(1920+350, 125); // Position the window's initial top-left corner
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
    glutCreateWindow("Rolling Ball : 1905084");
    glutDisplayFunc(display);
    glutKeyboardFunc(keyboardListener);
    glutSpecialFunc(specialKeyboardListener);
    glutIdleFunc(idle);
    init();


    glutMainLoop();
    return 0;

}